============= Dev Next branch (AffineUnits) =============
(1)  We need to store the inverse covariance (icov) instead of the state covaraince
      -   Our current error is (x'S*x) which is incorrect
      -   We need to use (x'*inv(S)*x)
      -   We have to calcualte inv(S) before we optimize (to simplify derivatives and avoid excessive matrix inversions)
      -   Look into estimating the Hessian directly for a new inv(S)
      -   Look at matrix inversion lemma (which lets us get away with one inversion):
               inv(F*G*H + E) â‰ˆ iE - iE*F*inv(iG + H*iE*F)*H*iE

(2)  Unit lookup for MeasInfo (cross validate during build if TagInfo or MeasInfo are missing tags)


============= DEV branch (Query results) =============
(1) Build query functions for PlantState and PlantSeries (values and stdevs) for main states (stream components, reactions etc)
     -  build out timeseries querying functions
           -   define getmeasurement(plant, measid), getstream(plant, streamid, component), getnode(plant, nodeid, component)
           -   these don't need to be performant, we can even iterate through the lists if need be
           -   stream variances are state standard deviations, others are measurement deviations
     -  produce a timeseries
           -   may want to extend TimeRecord for numerical operations like +-*/ and various univariate functions
           -   see what is implemented in https://github.com/JuliaLang/julia/blob/master/base/complex.jl





============= Port to parent "Carbon" application ====================
(O0) Develop workflow for model construction
     -  Prepare the global indexer ref to be used for all JSONs
     -  From JSON, Build Dict{Symbol, StreamInfo{L,String,N}} (t, p, moles are tags to pull from tagdict)
     -  From JSON, Build Vector{AbstractMeas{L,String,N}} (value is the tag to pull from the tagdict)
     -  From JSON, Build Vector{NodeInfo}{L,N} (no tags required, but reactions need to be parsed)
(O1) Create specific Species types 
     -  GhGSpecies{T} = Species{(:CO2, :CH4, :N2O, :Other), T, 4}
     -  AnalyzerSpecies{T} = Species{(...), T, length(...)}
(O2) Create a method to collapse AnalyzerSpecies to GhGSpecies
     -  gases = species(GhGSpecies)
     -  gastuple = map(gas-> get(analyzerspecies, gas, zero(T)), gases)
     -  ghgtuple = (gastuple[begin:(end-1)]..., sum(analyzerspecies) - sum(gastuple[begin:(end-1)]))
     -  return GhGSpecies{T}(ghgtuple)
(O3) Use these collapse methods to create methods to get attributes like
     -  molar_volumes(GhgSpecies, model, streaminfo)
     -  molar_weights(GhGSpecies, model, streaminfo)
(O4) A mass balance system must have a single set of components, but multiple systems can be merged
     -  Every "high-level system" contains the following elements:
          -  nodes Dict{Symbol, NodeInfo}
          -  streams Dict{Symbol, StreamInfo}
          -  proportions Dict{Symbol, (:parent, :proportion, :timeconstant)}
          -  measurements Dict{Symbol, NamedTuple{(:tags, :stream, :type)}}
          -  TimeRecord{GaussianState}
     -  This high level system in conjuction with "tagdict" is used to create a state space model with
          -  GaussianState
          -  predictor Tuple{A::Matrix{Float64}, Q::Matrix{Float64}}
          -  measurements MeasCollection
     -  Both models will have the merged node with the input and output streams
          -  Input => MergedNode => Output 
          -  The upstream model results provide a measurement to the downstream's "Input" stream
          -  The downstream model results provde a measurement to the upstreams's "Output" stream
     -  Only "intersecting" species can have non-zero values
          -  Other speceis are the average between input and output
     -  This will be useful for adding "combustion" units to the mass balance
          -  These will have a large number of components which would cause adjacent systems to have very large states
          -  This will also allow easy aggregation of streams to GhGSpecies
