============= DEV branch (dynamic reconciliation) =============
(1) Build code to reconcile entire timeseries
     -  Save the state and standard deviations as timeseries

(2) Build query functions for the state and stdevs for streams and reconciled measurements
     -  Use indexers to pull data 
     -  Produce a tabular JSON (for compact transmission)


============= Next branch (AffineUnits) (removing aggregation) =============
(1) Define AffineUnits extension to DynamicQuantities
     - Scale/Offset are for the formulas to convert INTO SI units
     - y{°C} = 5/9*x{°F} - 160/9  <=> 1°F = 5/9*°C - 160/9
     - y{K}  = 5/9*x{°F} + 255.37 <=> 1°F = 5/9*K  + 255.37 
(2) Add "units" to each measurement definition (and the JSON constructors)



============= Port to parent "Carbon" application ====================
(O0) Develop workflow for model construction
     -  Prepare the global indexer ref to be used for all JSONs
     -  From JSON, Build Dict{Symbol, StreamInfo{L,String,N}} (t, p, moles are tags to pull from tagdict)
     -  From JSON, Build Vector{AbstractMeas{L,String,N}} (value is the tag to pull from the tagdict)
     -  From JSON, Build Vector{NodeInfo}{L,N} (no tags required, but reactions need to be parsed)
(O1) Create specific Species types 
     -  GhGSpecies{T} = Species{(:CO2, :CH4, :N2O, :Other), T, 4}
     -  AnalyzerSpecies{T} = Species{(...), T, length(...)}
(O2) Create a method to collapse AnalyzerSpecies to GhGSpecies
     -  gases = species(GhGSpecies)
     -  gastuple = map(gas-> get(analyzerspecies, gas, zero(T)), gases)
     -  ghgtuple = (gastuple[begin:(end-1)]..., sum(analyzerspecies) - sum(gastuple[begin:(end-1)]))
     -  return GhGSpecies{T}(ghgtuple)
(O3) Use these collapse methods to create methods to get attributes like
     -  molar_volumes(GhgSpecies, model, streaminfo)
     -  molar_weights(GhGSpecies, model, streaminfo)
(O4) A mass balance system must have a single set of components, but multiple systems can be merged
     -  Every "high-level system" contains the following elements:
          -  nodes Dict{Symbol, NodeInfo}
          -  streams Dict{Symbol, StreamInfo}
          -  proportions Dict{Symbol, (:parent, :proportion, :timeconstant)}
          -  measurements Dict{Symbol, NamedTuple{(:tags, :stream, :type)}}
          -  TimeRecord{GaussianState}
     -  This high level system in conjuction with "tagdict" is used to create a state space model with
          -  GaussianState
          -  predictor Tuple{A::Matrix{Float64}, Q::Matrix{Float64}}
          -  measurements MeasCollection
     -  Both models will have the merged node with the input and output streams
          -  Input => MergedNode => Output 
          -  The upstream model results provide a measurement to the downstream's "Input" stream
          -  The downstream model results provde a measurement to the upstreams's "Output" stream
     -  Only "intersecting" species can have non-zero values
          -  Other speceis are the average between input and output
     -  This will be useful for adding "combustion" units to the mass balance
          -  These will have a large number of components which would cause adjacent systems to have very large states
          -  This will also allow easy aggregation of streams to GhGSpecies
