Current Branch (cleaning up refs)
(1) Spearate out StreamInfo and StreamRef
     -  StreamInfo is used to parse out the JSON
          -  Requires nominal flow and composition (or a reference to another stream with a scale)
          -  This is used to initialize the state, and build out "StreamRef"s
     -  StreamRef is used to reference the state vector
          -  Basicaly current StreamInfo without massflow

(2) Make all PlantInfo objects "Species" agnostic and easily constructable from JSON

(3) PlantState should have an overarching "thermodynamic model attached"
     -  In the future, Lumped models should have mutable mole fractions just in case

Merge to main and reset the DEV branch (removing aggregation)
(1) Remove aggregation from test and Stress-Test the system with a full composition rather than the abridged GHGs

(2) Add "referenced streams" to the model and stress-test the new configuration

Merge to main and reset the DEV branch (dynamic reconciliation)
(1) Build transitional code for multiple evaluations
     (1) Subtract mass balance errors to "MoleBalance" measurements, these must be saved for the next iteration
          -  0 = err[k] + sum(err[1:(k-1)])  ===>  -sum(err[1:(k-1)]) = err[k]

(2) Use the solved state and StreamInfo indexers to return labelled values of all streams (replace indexes with floats)
     -  Parent application can make any query they desire for this

Redefine lumped models
(1)  Remove current aggregation strategies (like totals and moleavgs), this adds a lot of complexity
     -  Instead support a basic model:
          BasicThermoModel = PR{BasicIdeal, PRAlpha, NoTranslation, vdW1fRule}
          struct SpeciesModel
               model :: BasicThermoModel
               comp  :: Vector (must sum to 1) #Set to [1] if pure species
               phase :: Symbol = :auto #Auto uses stream phase, but you can manually override this
          end
          -  Species can be a lumped substance with a fixed composition
     -  Models can be combined to a mixed model
          -  This is done once offline
          -  Moles of the mixed model would be reconstructed based off components
          struct ThermoModel{L, N} <: AbstractThermo{L}
               pure   :: Species{L, SpeciesModel, N}
               mixed  :: BasicModel #Obtained by concatenating components of all species models
          end



(Move GhsSpecies object outside of the package, into parennt environment)
(O0) Develop workflow for model construction
     -  Prepare the global indexer ref to be used for all JSONs
     -  From JSON, Build Dict{Symbol, StreamInfo{L,String,N}} (t, p, moles are tags to pull from tagdict)
     -  From JSON, Build Vector{AbstractMeas{L,String,N}} (value is the tag to pull from the tagdict)
     -  From JSON, Build Vector{NodeInfo}{L,N} (no tags required, but reactions need to be parsed)
(O1) Create specific Species types 
     -  GhGSpecies{T} = Species{(:CO2, :CH4, :N2O, :Other), T, 4}
     -  AnalyzerSpecies{T} = Species{(...), T, length(...)}
(O2) Create a method to collapse AnalyzerSpecies to GhGSpecies
     -  gases = species(GhGSpecies)
     -  gastuple = map(gas-> get(analyzerspecies, gas, zero(T)), gases)
     -  ghgtuple = (gastuple[begin:(end-1)]..., sum(analyzerspecies) - sum(gastuple[begin:(end-1)]))
     -  return GhGSpecies{T}(ghgtuple)
(O3) Use these collapse methods to create methods to get attributes like
     -  molar_volumes(GhgSpecies, model, streaminfo)
     -  molar_weights(GhGSpecies, model, streaminfo)
(O4) A mass balance system must have a single set of components, but multiple systems can be merged
     -  Every "high-level system" contains the following elements:
          -  nodes Dict{Symbol, NodeInfo}
          -  streams Dict{Symbol, StreamInfo}
          -  proportions Dict{Symbol, (:parent, :proportion, :timeconstant)}
          -  measurements Dict{Symbol, NamedTuple{(:tags, :stream, :type)}}
          -  TimeRecord{GaussianState}
     -  This high level system in conjuction with "tagdict" is used to create a state space model with
          -  GaussianState
          -  predictor Tuple{A::Matrix{Float64}, Q::Matrix{Float64}}
          -  measurements MeasCollection
     -  Both models will have the merged node with the input and output streams
          -  Input => MergedNode => Output 
          -  The upstream model results provide a measurement to the downstream's "Input" stream
          -  The downstream model results provde a measurement to the upstreams's "Output" stream
     -  Only "intersecting" species can have non-zero values
          -  Other speceis are the average between input and output
     -  This will be useful for adding "combustion" units to the mass balance
          -  These will have a large number of components which would cause adjacent systems to have very large states
          -  This will also allow easy aggregation of streams to GhGSpecies
