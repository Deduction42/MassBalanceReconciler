============= Next branch (AffineUnits) (removing aggregation) =============
(1)  Add a "units" field to the plant object
      -   units.tags is a dictionary that contains the units of all tags
          -   This is done here and not at the "measurement" level so that repeated tags don't result in "shotgun surgery"
          -   This also gives opportunity to check measurement tags against a master registry and give informative error messages
      -   units.registry defines any extra units this model would need to register
(2)  Constants in the measurement definition (such as standard conditions for volume) need to be strings that can be parsed as quantities or tags
      -   Attempt to look up the tag first in the unit registry
      -   If that fails, attempt to parse the string as a quantity "101.3 kPa" and convert to SI units
      -   If that fails, raise an error that the string value is not a tag and can't be parsed as a unit
(3)  Standard deviations for measuremnt definition must also be strings that are parsed as quantities
(4)  Test this with timeseries data

============= DEV branch (Query results) =============
(2) Build query functions for the state and stdevs for streams and reconciled measurements
     -  build out timeseries querying functions
           -   define getmeasurement(plant, id), getstream(plant, id), getnode(plant, id)
           -   these don't need to be performant, we can even iterate through the lists if need be
           -   stream variances are state standard deviations, others are measurement deviations
     -  Produce a tabular JSON (for compact transmission)





============= Port to parent "Carbon" application ====================
(O0) Develop workflow for model construction
     -  Prepare the global indexer ref to be used for all JSONs
     -  From JSON, Build Dict{Symbol, StreamInfo{L,String,N}} (t, p, moles are tags to pull from tagdict)
     -  From JSON, Build Vector{AbstractMeas{L,String,N}} (value is the tag to pull from the tagdict)
     -  From JSON, Build Vector{NodeInfo}{L,N} (no tags required, but reactions need to be parsed)
(O1) Create specific Species types 
     -  GhGSpecies{T} = Species{(:CO2, :CH4, :N2O, :Other), T, 4}
     -  AnalyzerSpecies{T} = Species{(...), T, length(...)}
(O2) Create a method to collapse AnalyzerSpecies to GhGSpecies
     -  gases = species(GhGSpecies)
     -  gastuple = map(gas-> get(analyzerspecies, gas, zero(T)), gases)
     -  ghgtuple = (gastuple[begin:(end-1)]..., sum(analyzerspecies) - sum(gastuple[begin:(end-1)]))
     -  return GhGSpecies{T}(ghgtuple)
(O3) Use these collapse methods to create methods to get attributes like
     -  molar_volumes(GhgSpecies, model, streaminfo)
     -  molar_weights(GhGSpecies, model, streaminfo)
(O4) A mass balance system must have a single set of components, but multiple systems can be merged
     -  Every "high-level system" contains the following elements:
          -  nodes Dict{Symbol, NodeInfo}
          -  streams Dict{Symbol, StreamInfo}
          -  proportions Dict{Symbol, (:parent, :proportion, :timeconstant)}
          -  measurements Dict{Symbol, NamedTuple{(:tags, :stream, :type)}}
          -  TimeRecord{GaussianState}
     -  This high level system in conjuction with "tagdict" is used to create a state space model with
          -  GaussianState
          -  predictor Tuple{A::Matrix{Float64}, Q::Matrix{Float64}}
          -  measurements MeasCollection
     -  Both models will have the merged node with the input and output streams
          -  Input => MergedNode => Output 
          -  The upstream model results provide a measurement to the downstream's "Input" stream
          -  The downstream model results provde a measurement to the upstreams's "Output" stream
     -  Only "intersecting" species can have non-zero values
          -  Other speceis are the average between input and output
     -  This will be useful for adding "combustion" units to the mass balance
          -  These will have a large number of components which would cause adjacent systems to have very large states
          -  This will also allow easy aggregation of streams to GhGSpecies
